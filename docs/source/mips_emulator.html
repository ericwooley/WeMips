<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='mips_emulator-method-mips_emulator'>/**
</span> * Mips emulator constructor
 * @param  {Object} mips_args Arguments to construct the mips emulater.
 * @param mips_args.starting_code Set the default code for this emulator to run.
 * @param mips_args.debug If debug is set to true, the console will print debug statements
 * @return {mips_emulator}
 * @member mips_emulator
 */
function mips_emulator(mips_args){
    mips_args = mips_args || {};
    mips_args = _.defaults(mips_args, {
        starting_code: null,
        debug: false,
        onError: function(line, error){alert(error)},
        onRegisterChange: function(reg_name, new_value) {

        },
        onFinish: function(){
            alert(&quot;Finished running emulation, resetting $sp to line 1&quot;);
        }
    });
    var debug = mips_args.debug
    //////////////////////////////////
    // Private Variables / Setup
    //////////////////////////////////
    
   var stack = new Stack();

<span id='mips_emulator-property-registers'>    /**
</span>     * Hash table of registers
     * @property registers
     * @private
     * @member mips_emulator
     * @type {Object}
     */
    var registers = {};
<span id='mips_emulator-property-readwriteRegs'>    /**
</span>     * Array of read/write registers
     * @property readwriteRegs
     * @private
     * @member mips_emulator
     * @type {Array}
     */
    var readwriteRegs = [
        &#39;$s0&#39;, &#39;$s1&#39;, &#39;$s2&#39;, &#39;$s3&#39;, &#39;$s4&#39;, &#39;$s5&#39;, &#39;$s6&#39;, &#39;$s7&#39;,
        &#39;$t0&#39;, &#39;$t1&#39;, &#39;$t2&#39;, &#39;$t3&#39;, &#39;$t4&#39;, &#39;$t5&#39;, &#39;$t6&#39;, &#39;$t7&#39;, &#39;$t8&#39;, &#39;$t9&#39;,
        &#39;$v0&#39;, &#39;$v1&#39;,
        &#39;$a0&#39;, &#39;$a1&#39;, &#39;$a2&#39;, &#39;$a3&#39;,
        &#39;$sp&#39;
    ];

<span id='mips_emulator-property-readonlyRegs'>    /**
</span>     * Array of read only registers
     * @property readonlyRegs
     * @private
     * @member mips_emulator
     * @type {Array}
     */
    var readonlyRegs = [
        &#39;$zero&#39;, &#39;$at&#39;,
        &#39;$k0&#39;, &#39;$k1&#39;,
        &#39;$gp&#39;, &#39;$fp&#39;, &#39;$ra&#39;
    ];
    // The intial line where we start the emulation.
<span id='mips_emulator-property-current_line'>    /**
</span>     * The current line the mips emulator is looking at.
     * @property current_line
     * @private
     * @member mips_emulator
     * @type {Number}
     */
    var current_line = 1;
    // populate registers with all the read and write registers and set their inital values to random
    for (var i = 0; i &lt; readwriteRegs.length; i++) {
        registers[readwriteRegs[i]] = create_register({
            writable: true,
            reg_name:readwriteRegs[i] 
        });
    };

    // populate registers with all the read and write registers and set their inital values to random
    for (var i = 0; i &lt; readonlyRegs.length; i++) {
        registers[readonlyRegs[i]] = create_register({
            writable: false,
            reg_name: readonlyRegs[i]
        });
    };
    registers.$zero.val = 0;
    registers.$sp.val = stack.pointerToBottomOfStack();

    // Object that will contain analyzed code information
<span id='mips_code'>    /**
</span>     * @class mips_code
     * @private
     * @member mips_emulator
     * Object that keeps the code to be executed
     * @type {Object}
     */
    var mips_code = {
<span id='mips_code-property-code'>        /**
</span>         * Array of lines that can be exectued
         * @property code
         * @member mips_code
         * @type {Array}
         */
        code:[null], // Initialize with null in the 0 place, to make line numbers line up.
<span id='mips_code-property-labels'>        /**
</span>         * Hashtable of labels pointing to lines of code
         * @property labels
         * @member mips_code
         * @type {Object}
         */
        labels: {}
    };
    // Public methods
<span id='mips_emulator'>    /**
</span>     * @class mips_emulator
     * Mips Emulation engine.
     */
    var ME = {
<span id='mips_emulator-method-getRegister'>        /**
</span>         * Returns a specified registers value
         * @member mips_emulator
         * @param  {String} reg
         * @return {String} 
         */
        getRegister: function(reg){
            if(reg.charAt(0) != &#39;$&#39;){
                reg = &#39;$&#39; + reg;
            }
            if(!registers[reg]) return false;
            return registers[reg].val;    
            
        },
<span id='mips_emulator-method-setRegister'>        /**
</span>         * Set a register value, and call onChange function for that register
         * @member mips_emulator
         * @param {String} reg
         * @param {Number} value
         */
        setRegister: function(reg, value, enable_callback){
            enable_callback = enable_callback || true;
            if(reg.charAt(0) != &#39;$&#39;){
                reg = &#39;$&#39; + reg;

            }
            if(debug) console.log(&quot;Setting register &quot; + reg + &quot; to &quot; + value);

            if(!registers[reg]) return false;
            // TODO: ensure the register name does not exist in readonlyRegs (or better yet, ensure it exists in the readwriteRegs)
            if(registers[reg].onChange &amp;&amp; enable_callback) registers[reg].onChange();
                registers[reg].val = value;
            if(mips_args.onRegisterChange &amp;&amp; enable_callback)
                mips_args.onRegisterChange(reg, value);
            if(debug) console.log(&quot;----&gt; New value: &quot;+ ME.getRegister(reg));

        },
<span id='mips_emulator-method-onChange'>        /**
</span>         * Set an Onchange function for a register
         * @member mips_emulator
         * @param  {String} reg
         * @param  {Function} func
         * @return {null}
         */
        onChange: function(reg, func){
            registers[reg].onChange = func;
        },
<span id='mips_emulator-method-setLine'>        /**
</span>         * Set which line to run next.
         * @member mips_emulator
         * @param {Number} line_no
         * @return {Number} Returns the number the line was set too.
         */
        setLine: function(line_no){
            var line = mips_code.code[line_no];
            if(debug) console.log(&quot;setting line: &quot;+ line_no + &quot; - &quot; + JSON.stringify(line));
            if(!line) return false;
            current_line = line_no;
            if(line.ignore) increment_line();
            return current_line;
        },
<span id='mips_emulator-method-isRegister'>        /**
</span>         * Checks if a register is a valid register
         * @member mips_emulator
         * @param  {String}  reg
         * @return {Boolean}
         */
        isRegister: function(reg){
            return registers[reg] &amp;&amp; typeof(registers[reg]) !== &#39;undefined&#39;;
        },
<span id='mips_emulator-method-isValidLine'>        /**
</span>         * Checks if a string is a valid mips line
         * @member mips_emulator
         * @param  {String}  line
         * @return {Boolean}
         */
        isValidLine: function(line){
            return !(new mips_line(line).error);
        },
<span id='mips_emulator-method-setCode'>        /**
</span>         * Set code to be emulated
         * @member mips_emulator
         * @param {String} mc
         */
        setCode: function(mc){   
            console.log(&quot;Analyzing...&quot;);
            mips_code.code = [null];
            $.each(mc.split(&#39;\n&#39;), function(index, val){
                var line = new mips_line(val);
                line.line_no = mips_code.code.length; // save the line number
                console.log(JSON.stringify(line));
                mips_code.code.push(line);
            });
        },
<span id='mips_emulator-method-runLine'>        /**
</span>         * Run an individual line
         * @member mips_emulator
         * @param  {String} input_line 
         * @return {null}
         */
        runLine: function(input_line) {
            var line = new mips_line(input_line);
            run_line(line);
        },
<span id='mips_emulator-method-step'>        /**
</span>         * execute the line $sp is pointing at.
         * @member mips_emulator
         * @return {Object}
         * returns object.line_ran which is the line that was just run
         * and object.next_line which is the line that is about to be run.
         */
        step: function(){
            if(debug) console.log(&quot;Running line: &quot; + current_line + &quot; - &quot; + mips_code.code[current_line]);
            var ret = {
                line_ran: Number(current_line)
            };

            run_line(mips_code.code[current_line]);
            ret.next_line = current_line;
            if(current_line &gt; mips_code.code.length) return finish_emulation();
            else return ret;
        },
<span id='mips_emulator-method-get_line_number'>        /**
</span>         * Returns the current line number (the next to be run)
         * @return {Number}
         */
        get_line_number: function(){
            return current_line;
        }
    };


    ////////////////////////////////////////////////
    // Private Methods
    ////////////////////////////////////////////////
    function finish_emulation(){
        mips_args.onFinish();
        if(debug) console.log(&quot;Emulation finished. Returning to line: &quot; + ME.setLine(1));
        else ME.setLine(1);
    }
<span id='mips_emulator-property-parseMethods'>    /**
</span>     * Verifies that an operation can use these registers
     * @member mips_emulator
     * @private
     * @type {Object}
     */
    var parseMethods = {
        &#39;ADD&#39;: function(line) {
            // Grab each register from the registers
            line.rd = registers[line.args[0]];
            line.rs = registers[line.args[1]];
            line.rt = registers[line.args[2]];
            // $rd must be writable
            if(line.rd &amp;&amp; !line.rd.writable) line.error = &quot;Register &quot; + line.rd + &quot; is not writable&quot;;
            if(line.error) console.warn(&quot;Error parsing line: &quot; +line.error +&quot;\n&quot; + JSON.stringify(line));
            return line.error || (line.rd &amp;&amp; line.rs &amp;&amp; line.rt);
        },
        &#39;ADDI&#39;: function(line) {
            line.rt = registers[line.args[0]];
            line.rs = registers[line.args[1]];
            line.imm = getImmediate(line.args[2]);

            return line.rt &amp;&amp; line.rs &amp;&amp; line.imm;
        }
    };
<span id='mips_emulator-method-increment_line'>    /**
</span>     * Increments the current line to the next line which is not ignored.
     * @return {null}
     */
    function increment_line(){
        current_line++;
        while(mips_code.code[current_line]
                &amp;&amp; current_line &lt;= mips_code.code.length
                &amp;&amp; mips_code.code[current_line].ignore != false
        ){
            if(debug) console.log(&quot;ignoring line: &quot; + current_line);
            current_line++;
        }
    }
<span id='mips_emulator-method-run_line'>    /**
</span>     * Run an individual line
     * @member mips_emulator
     * @private
     * @return {null}
     */
    function run_line(line) {
        if (!line || line.ignore || line.error) {
            current_line++;
            if(!line) return &quot;Line is null&quot;;
            return line.error; // returns error if there is one or null if not.
        }
        // we can assume that we parsed successfully at this point.
        runMethods[line.instruction](line);

    };

<span id='mips_emulator-method-create_register'>    /**
</span>     * Create a default register
     * @member mips_emulator
     * @private
     * @param  {Object} reg
     * @return {register}
     */
    function create_register(reg){
<span id='register'>        /**
</span>         * @class register
         * contains register information.
         */
        var register = {
<span id='register-property-val'>            /**
</span>             * registers value
             * @property
             * @type {Number}
             */
            val: Math.floor((Math.random()*1000)), // Set the initial register data to garbage
<span id='register-property-onChange'>            /**
</span>             * Function that is called when this register is changed.
             * @type {Function}
             */
            onChange: null,
<span id='register-property-writable'>            /**
</span>             * Wether or not this register is writable (false if this register is read only)
             * @type {Boolean}
             */
            writable: true,
<span id='register-property-reg_name'>            /**
</span>             * This registers name
             * @type {String}
             */
            reg_name: null
        };
        _.defaults(reg, register);
        return reg;
    };
    // these will be called after the parse method has been called
    // the goal is to make these methods look as close to the MIPS cheat sheet as possible.
    
<span id='mips_emulator-property-runMethods'>    /**
</span>     * Collection of methods to run the intended operations.
     * @member mips_emulator
     * @private
     * @type {Object}
     */
    var runMethods = {
        &#39;ADD&#39;: function(line) {
            //reg[line.rd] = reg[line.rs] + reg[line.rt];
            if(debug) console.log(&quot;running add: &quot; + JSON.stringify(line));
            if(debug) console.log(line.rs.val + &quot; + &quot; + line.rt.val + &quot; = &quot; + (line.rs.val + line.rt.val) + &quot; Saved to: &quot;+ line.rd.reg_name);
            ME.setRegister(line.rd.reg_name, line.rs.val + line.rt.val);
            increment_line();
        },
        &#39;ADDI&#39;: function(line) {
            //reg[line.rt] = reg[line.rs] + line.imm;
            ME.setRegister(line.rt.reg_name, line.rs.val + line.imm);
            increment_line();
        }   
    };
<span id='mips_emulator-method-getImmediate'>    /**
</span>     * check if argument is an immediate, parse, and return the results.
     * @member mips_emulator
     * @private
     * @param  {String} arg
     * @return {Number}
     */
    function getImmediate(arg) {
        if (isImmediate(arg)) {
            return parseInt(arg, 10);
        }
        return null;
    };
<span id='mips_emulator-method-isImmediate'>    /**
</span>     * Checks if a string matches as a number
     * @member mips_emulator
     * @private
     * @param  {String}  arg
     * @return {Boolean}
     */
    function isImmediate(arg) {
        return /^[-+]?\d+$/.test(arg);
    };


<span id='mips_emulator-method-mips_line'>    /**
</span>     * Turns a string into a mips line object which contains a mips line of code and metadata needed to run it
     * @member mips_emulator
     * @private
     * @param  {String} line
     * @return {Object}
     */
    function mips_line(line){

        // Object that will save information about a line of code.
<span id='line'>        /**
</span>         * @class line
         * Contains information about a single line of mips code
         * @member mips_emulator
         * @private
         */
        var LINE = {
<span id='line-property-args'>            /**
</span>             * Arguments for this line of code ex: [$t0, $s0, $zero]
             * @property
             * @type {Array}
             */
            args: [],
<span id='line-property-instruction'>            /**
</span>             * The lines instruction ex: ADD
             * @type {String}
             */
            instruction: null,
<span id='line-property-ignore'>            /** 
</span>             * flag to indicate weather this line should be ignored (not run).
             * @type {Boolean}
             */
            ignore: true, 
<span id='line-property-comment'>            /**
</span>             * The comment (if any) that this line of code contained
             * @type {String}
             */
            comment: &#39;&#39;, 
<span id='line-property-label'>            /**
</span>             * The label for this line of code
             * @type {String}
             */
            label: &#39;&#39;, 
<span id='line-property-error'>            /**
</span>             * Error when running this line of code (if any)
             * @type {String}
             */
            error: null
        };


        //console.log(&quot;--&gt; &quot;+val);
        var regex = /^\s*(?:(\w+)\s*:\s*)?(?:(\w+)\s+([^#]+))?(?:#\s*(.*))?$/;
        var ar = line.match(regex);
        // when matched the array contains the following
        // ----&gt; [0] The entire line
        // ----&gt; [1] The label without the &#39;:&#39;
        // ----&gt; [2] The instruction (e.g. &#39;ADD&#39;, &#39;LW&#39;, etc.)
        // ----&gt; [3] The arguments (e.g. &#39;$rd, $rs, $rt&#39;), this should be trimmed
        // ----&gt; [4] The comment without the &#39;#&#39;, this should be trimmed
        // if ar is null, that means the regex didn&#39;t match

        if(ar){
            // if we have a label, save it to the hashtable and save it to line
            if(ar[1] &amp;&amp; ar[1].length &gt; 0){
                LINE.label = ar[1];
                // TODO: mips_code.labels[ar[1]] = line;
            }

            // If we got variables back
            if(ar[3]){
                // Split the args by `,`
                LINE.args = ar[3].split(&#39;,&#39;);

                // Trim the varaibles
                for(var i = 0; i &lt; LINE.args.length; i++){
                   LINE.args[i] = $.trim(LINE.args[i]);
                }
            }

            // The instruction for this code;
            LINE.instruction = $.trim(ar[2]).toUpperCase();

            // If the line has an instruction, we should not ignore it. otherwise it may be a comment or blank
            if(LINE.instruction &amp;&amp; LINE.instruction.length &gt; 0) LINE.ignore = false;

            // The comment, obviously
            LINE.comment = $.trim(ar[4]);

            // parse the instruction now, so it can be executed whenever we want
            if (LINE.instruction) {
                // an instruction was found, so try to parse it
                var parseMethod = parseMethods[LINE.instruction];
                if (!parseMethod) {
                    LINE.error = &quot;Error. Unknown instruction: &quot; + LINE.instruction;
                } else if (!parseMethod(LINE)) {
                    LINE.error = &quot;Error. Invalid arguments: &quot; + LINE.args;
                }
            };

        // In the else case, the regex didn&#39;t match, possible error?
        } else {
            // TODO: check for special cases
            LINE.error = &quot;Error parsing line: &quot;+ (index+1);
            console.log(&quot;----&gt; No matches&quot;);
        }
        //if(debug) console.log(&quot;Finished parsing line: &quot; + JSON.stringify(LINE));
        return LINE;
    }

    // Set the starting code if there was any.
    if(mips_args.starting_code) ME.setCode(mips_args.starting_code);
    return ME;
}</pre>
</body>
</html>
