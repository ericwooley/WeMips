<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">function StackError(message) {
    this.name = StackError.exceptionName();
    this.message = message;
}
StackError.exceptionName = function() {
    return &#39;Stack Error&#39;;
}
StackError.prototype.toString = function() {
    return &#39;{0}: {1}&#39;.format(this.name, this.message);
}

function Stack(options) {
    options = options || {};
    _.defaults(options, {
<span id='Stack-property-onChange'>        /**
</span>         * Function to call when the stack changes. (e.g. onChange(indexNumber))
         * @member Stack
         * @type {Function}
         */
        onChange: null,
<span id='Stack-property-onAdd'>        /**
</span>         * Function to call when the stack gets new elements. (e.g. onAdd(indexNumber))
         * @member Stack
         * @type {Function}
         */
        onAdd: null,
        baseAddress: Math.floor((Math.random()*999999)) + 10000
    });

    // Private memebers

    var that = this; // see http://javascript.crockford.com/private.html

    // The stack will be implemented as a single array where each
    // element will store a single byte (e.g. a number between 0 and 255).
    var data = [];

    function getByteAtAddress(address) {
        return data[indexForAddress(address)];
    }
    function setByteAtAddress(address, byte) {
        assert(typeof byte === &quot;number&quot;);
        assert(0 &lt;= byte &amp;&amp; byte &lt;= 255);
        data[indexForAddress(address)] = byte;
        if (options.onChange) options.onChange(address);
    }
    function indexForAddress(address) {
        // get the index into the data array which corresponds to a specific address
        assert(typeof address == &quot;number&quot;);
        var minValidAddress = 0;
        var maxValidAddress = that.pointerToBottomOfStack() - 1;
        if (address &lt; minValidAddress || maxValidAddress &lt; address) {
            throw new StackError(&#39;Invalid stack address ({0}). Valid stack addresses are between {1} and {2}.&#39;.format(address, minValidAddress, maxValidAddress));
        }

        // Conversion to index:
        // 1. Assume a base address of 100.
        // 2. The first accessible address is 99, which will be stored in 0.
        // 3. The next accessible address is 98, which will be stored in 1.
        var index = (options.baseAddress - 1) - address;

        // ensure this index is accessible
        var numElementsToAdd = index - data.length + 1;
        for (var i = 0; i &lt; numElementsToAdd; i++) {
            var randomNumFrom0to255 = Math.floor((Math.random()*256));
            data.push(randomNumFrom0to255);
            if (options.onAdd) options.onAdd(data.length - 1);
        }
        return index;
    }

    // Public variables

    this.MIN_BYTE_VALUE = 0;
    this.MAX_BYTE_VALUE = 255;
    this.BITS_PER_BYTE = 8;
    this.BYTES_PER_BYTE = 1;
    this.BYTES_PER_HALFWORD = 2;
    this.BYTES_PER_WORD = 4;

    // Privileged methods

    this.getDataAtAddress = function (address, byteCount, asUnsigned) {
        asUnsigned = asUnsigned || false;
        var result = 0;
        for (var i = 0; i &lt; byteCount; i++) {
            var value = getByteAtAddress(address + i);
            assert(this.MIN_BYTE_VALUE &lt;= value &amp;&amp; value &lt;= this.MAX_BYTE_VALUE);
            result = result &lt;&lt; this.BITS_PER_BYTE;
            result += value;
        };
        if (asUnsigned) {
            return result;
        } else {
            return Stack.unsignedNumberToSignedNumber(result, byteCount * this.BITS_PER_BYTE);
        }
    };
    this.setDataAtAddress = function(address, byteCount, data) {
        assert(typeof data === &quot;number&quot;, &quot;Only numbers supported for now.&quot;);
        if (data &lt; 0) {
            data = Stack.signedNumberToUnsignedNumber(data, byteCount * this.BITS_PER_BYTE);
        }
        var minValidValue = 0;
        var maxValidValue = (Math.pow(256, byteCount) - 1);
        if (data &lt; minValidValue || maxValidValue &lt; data) {
            throw new StackError(&#39;Unable to store out-of-range value ({0}). Valid values are {1} through {2}.&#39;.format(data, minValidValue, maxValidValue));
        };
        for (var i = byteCount - 1; i &gt;= 0; i--) {
            var rightMostByte = data &amp; this.MAX_BYTE_VALUE;
            setByteAtAddress(address + i, rightMostByte);
            data = data &gt;&gt; this.BITS_PER_BYTE;
        };
    };
    this.reset = function() {
        data = [];
    };
    this.pointerToBottomOfStack = function () {
        // the initial value of the stack pointer. before you read or write to it, you must decrement the stack pointer.
        return options.baseAddress;
    };
}

// Public functions

Stack.prototype.getByte = function (pointer) {
    return this.getDataAtAddress(pointer, this.BYTES_PER_BYTE);
};

Stack.prototype.getUnsignedByte = function (pointer) {
    return this.getDataAtAddress(pointer, this.BYTES_PER_BYTE, true);
};

Stack.prototype.getHalfword = function (pointer) {
    return this.getDataAtAddress(pointer, this.BYTES_PER_HALFWORD);
};

Stack.prototype.getUnsignedHalfword = function (pointer) {
    return this.getDataAtAddress(pointer, this.BYTES_PER_HALFWORD, true);
};

Stack.prototype.getWord = function (pointer) {
    return this.getDataAtAddress(pointer, this.BYTES_PER_WORD);
};

Stack.prototype.getUnsignedWord = function (pointer) {
    return this.getDataAtAddress(pointer, this.BYTES_PER_WORD, true);
};

Stack.prototype.setByte = function (pointer, data) {
    this.setDataAtAddress(pointer, this.BYTES_PER_BYTE, data);
};

Stack.prototype.setHalfword = function (pointer, data) {
    this.setDataAtAddress(pointer, this.BYTES_PER_HALFWORD, data);
};

Stack.prototype.setWord = function (pointer, data) {
    this.setDataAtAddress(pointer, this.BYTES_PER_WORD, data);
};

// Public Helper functions

Stack.stringToNumber = function (string) {
    assert(typeof string === &quot;string&quot;);
    var number = 0;
    for (var i = 0; i &lt; string.length; i++) {
        number = number &lt;&lt; 8;
        number += string.charCodeAt(i);
    };
    return number;
};

Stack.numberToString = function (number) {
    assert(typeof number === &quot;number&quot;);
    var string = &#39;&#39;;
    while (0 &lt; number) {
        string = String.fromCharCode(number &amp; 255) + string;
        number = number &gt;&gt; 8;
    }
    return string;
};

Stack.numberToBinaryString = function (number, bits/*=32*/) {
    // returns a binary representation of a string.
    assert(typeof number === &quot;number&quot;);

    bits = bits || 32;
    assert(typeof bits === &quot;number&quot;);

    if (number &lt; 0) {
        // convert to the corresponding unsigned number (e.g. when we are using single bytes, then -2 would correspond to 254, since the two are represented the same in binary)
        number = Math.pow(2, bits) + number;
    }

    var result = number.toString(2);
    var zeroPadding = (new Array(bits - result.length + 1)).join(&#39;0&#39;);
    return zeroPadding + result;
}

Stack.binaryStringToNumber = function (binaryString) {
    assert(typeof binaryString == &quot;string&quot;);

    var unsignedNumber = Stack.binaryStringToUnsignedNumber(binaryString);
    if (binaryString[0] === &quot;0&quot;) {
        // this is a positive number
        return unsignedNumber;
    }

    assert(binaryString[0] === &quot;1&quot;, &quot;This should be a negative number.&quot;);
    return Stack.unsignedNumberToSignedNumber(unsignedNumber, binaryString.length); // unsignedNumber - Math.pow(2, binaryString.length);
}

Stack.binaryStringToUnsignedNumber = function (binaryString) {
    assert(typeof binaryString == &quot;string&quot;);
    return parseInt(binaryString, 2);
}

Stack.unsignedNumberToSignedNumber = function (number, bits/*=32*/) {
    assert(typeof number === &quot;number&quot;);
    bits = bits || 32;
    assert(typeof bits === &quot;number&quot;);
    assert(0 &lt;= number &amp;&amp; number &lt; Math.pow(2, bits), &quot;Out of range.&quot;);
    if (number &lt; Math.pow(2, bits - 1)) {
        // e.g. f(3, 8) -&gt; 3, since 0000 0011 in signed and unsigned is always 3
        return number;
    };

    // e.g. f(255, 8) -&gt; -1, since -1 and 255 (1111 1111) represent the same value in binary
    // e.g. f(254, 8) -&gt; -2, since they represent the same number in binary (1111 1110)
    return number - Math.pow(2, bits);
}


Stack.signedNumberToUnsignedNumber = function (number, bits/*=32*/) {
    // e.g. f(-128, 8) -&gt; 128 (1000 0000)
    // e.g. f(-1, 8) -&gt; 255   (1111 1111)
    // e.g. f(-2, 8) -&gt; 254   (1111 1110)
    // e.g. f(127, 8) -&gt; 127  (0111 1111)
    // e.g. f(255, 8) -&gt; 255  (1111 1111)
    // e.g. f(3, 8) -&gt; 3      (0000 0011)
    assert(typeof number === &quot;number&quot;);
    bits = bits || 32;
    assert(typeof bits === &quot;number&quot;);
    var minValidValue = -Math.pow(2, bits-1);
    var maxValidValue = Math.pow(2, bits) - 1;
    if (number &lt; minValidValue || maxValidValue &lt; number) {
        throw new StackError(&quot;Out of range value ({0}) for conversion of signed to unsigned number. The value must be between {1) and {2}.&quot;.format(number, minValidValue, maxValidValue));
    };

    if (0 &lt;= number) {
        return number;
    }

    // negative number
    return number + Math.pow(2, bits);
}

// TODO: move this elsewhere
function assert(condition, message) {
    if (!condition) {
        throw message || &quot;Assertion failed&quot;;
    }
}

String.prototype.format = function() {
    // &#39;Added {0} by {1} to your collection&#39;.format(title, artist)
    // http://stackoverflow.com/a/2648463
    var s = this,
        i = arguments.length;

    while (i--) {
        s = s.replace(new RegExp(&#39;\\{&#39; + i + &#39;\\}&#39;, &#39;gm&#39;), arguments[i]);
    }
    return s;
};</pre>
</body>
</html>
